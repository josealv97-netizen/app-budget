import { createContext, useContext, useState, useEffect } from 'react';
import { v4 as uuidv4 } from 'uuid';
import {
    startOfMonth, endOfMonth, eachDayOfInterval, format,
    addMonths, isSameDay, startOfDay, subMonths, isBefore, isAfter
} from 'date-fns';
import { fr } from 'date-fns/locale';
import { supabase } from '../supabase';

const DataContext = createContext();

export const DataProvider = ({ children }) => {
    const [data, setData] = useState({
        transactions: [],
        recurring: [],
        categories: [],
        limits: [],
        preferences: {
            initialBalance: 0,
            startDate: format(new Date(), 'yyyy-MM-01')
        },
        loading: true
    });

    const fetchData = async () => {
        try {
            const [cats, trans, recur, prefs, limits] = await Promise.all([
                supabase.from('categories').select('*'),
                supabase.from('transactions').select('*'),
                supabase.from('recurring_transactions').select('*'),
                supabase.from('preferences').select('*'),
                supabase.from('monthly_limits').select('*')
            ]);

            if (cats.error) throw cats.error;
            if (trans.error) throw trans.error;
            if (recur.error) throw recur.error;
            if (prefs.error) throw prefs.error;
            // limits might be empty or error if table doesn't exist yet, handle gracefully if possible or assume user ran SQL
            // validation omitted for speed, assuming happy path after SQL run
            const limitsData = limits.data || [];

            // Process Data
            const categories = cats.data;

            // Map Transactions: category_id -> category name for UI compatibility
            const transactions = trans.data.map(t => {
                const cat = categories.find(c => c.id === t.category_id);
                return {
                    ...t,
                    category: cat ? cat.name : 'Inconnu',
                };
            }).sort((a, b) => new Date(b.date) - new Date(a.date));

            // Map Recurring: category_id -> category name
            const recurring = recur.data.map(r => {
                const cat = categories.find(c => c.id === r.category_id);
                return {
                    ...r,
                    category: cat ? cat.name : 'Inconnu',
                    dayOfMonth: r.day_of_month // map snake_case to camelCase
                };
            });

            // Preferences
            const prefData = prefs.data[0] || { initial_balance: 0, start_date: format(new Date(), 'yyyy-MM-01') };
            const preferences = {
                id: prefData.id,
                initialBalance: prefData.initial_balance,
                startDate: prefData.start_date
            };

            setData({
                transactions,
                recurring,
                categories,
                preferences,
                limits: limitsData,
                loading: false
            });

        } catch (error) {
            console.error("Error fetching data:", error);
        }
    };

    useEffect(() => {
        fetchData();
    }, []);

    // --- Actions ---

    const addTransaction = async (transaction) => {
        // Find Category ID
        const cat = data.categories.find(c => c.name === transaction.category);
        const category_id = cat ? cat.id : null;

        // Optimistic Update
        const tempId = uuidv4(); // Temporary ID for UI
        const newTransaction = { ...transaction, id: tempId, date: transaction.date || new Date().toISOString() };

        setData(prev => ({
            ...prev,
            transactions: [newTransaction, ...prev.transactions].sort((a, b) => new Date(b.date) - new Date(a.date))
        }));

        const { data: inserted, error } = await supabase.from('transactions').insert([{
            description: transaction.description,
            amount: transaction.amount,
            type: transaction.type,
            date: transaction.date || new Date().toISOString(),
            category_id: category_id,
            is_auto_generated: transaction.isAutoGenerated || false
        }]).select();

        if (error) {
            console.error("Error adding transaction:", error);
            // Rollback logic would go here
        } else if (inserted) {
            // Replace optimistic data with real data (ID)
            fetchData(); // Simplest way to sync IDs
        }
    };

    const updateTransaction = async (id, updates) => {
        // Optimistic
        setData(prev => ({
            ...prev,
            transactions: prev.transactions
                .map(t => t.id === id ? { ...t, ...updates } : t)
                .sort((a, b) => new Date(b.date) - new Date(a.date))
        }));

        // Prep updates for DB
        const dbUpdates = {};
        if (updates.description) dbUpdates.description = updates.description;
        if (updates.amount) dbUpdates.amount = updates.amount;
        if (updates.date) dbUpdates.date = updates.date;
        if (updates.type) dbUpdates.type = updates.type;
        if (updates.category) {
            const cat = data.categories.find(c => c.name === updates.category);
            if (cat) dbUpdates.category_id = cat.id;
        }

        const { error } = await supabase.from('transactions').update(dbUpdates).eq('id', id);
        if (error) console.error("Error updating transaction:", error);
    };

    const removeTransaction = async (id) => {
        setData(prev => ({
            ...prev,
            transactions: prev.transactions.filter(t => t.id !== id)
        }));

        const { error } = await supabase.from('transactions').delete().eq('id', id);
        if (error) console.error("Error deleting transaction:", error);
    };

    const addRecurring = async (item) => {
        const cat = data.categories.find(c => c.name === item.category);
        const category_id = cat ? cat.id : null;

        const { data: inserted, error } = await supabase.from('recurring_transactions').insert([{
            description: item.description,
            amount: item.amount,
            type: item.type,
            day_of_month: item.dayOfMonth,
            category_id: category_id
        }]).select();

        if (!error && inserted) {
            fetchData();
        }
    };

    const updateRecurring = async (id, updates) => {
        const dbUpdates = {};
        if (updates.description) dbUpdates.description = updates.description;
        if (updates.amount) dbUpdates.amount = updates.amount;
        if (updates.dayOfMonth) dbUpdates.day_of_month = updates.dayOfMonth;
        if (updates.category) {
            const cat = data.categories.find(c => c.name === updates.category);
            if (cat) dbUpdates.category_id = cat.id;
        }
        if (updates.type) dbUpdates.type = updates.type;

        await supabase.from('recurring_transactions').update(dbUpdates).eq('id', id);
        fetchData();
    };

    const removeRecurring = async (id) => {
        await supabase.from('recurring_transactions').delete().eq('id', id);
        fetchData();
    }

    const updatePreferences = async (updates) => {
        const dbUpdates = {};
        if (updates.initialBalance !== undefined) dbUpdates.initial_balance = updates.initialBalance;
        if (updates.startDate) dbUpdates.start_date = updates.startDate;

        // Assumes only 1 row in preferences
        if (data.preferences.id) {
            await supabase.from('preferences').update(dbUpdates).eq('id', data.preferences.id);
        } else {
            await supabase.from('preferences').insert([dbUpdates]);
        }
        fetchData();
    };

    const addCategory = async (category) => {
        await supabase.from('categories').insert([{
            name: category.name,
            type: category.type,
            color: category.color,
            icon: category.icon
        }]);
        fetchData();
    }

    const removeCategory = async (id) => {
        await supabase.from('categories').delete().eq('id', id);
        fetchData();
    };

    const addLimit = async (limit) => {
        const { error } = await supabase.from('monthly_limits').insert([{
            name: limit.name,
            amount: limit.amount,
            category_ids: limit.category_ids
        }]);
        if (error) console.error("Error adding limit:", error);
        fetchData();
    };

    const updateLimit = async (id, updates) => {
        const { error } = await supabase.from('monthly_limits').update({
            name: updates.name,
            amount: updates.amount,
            category_ids: updates.category_ids
        }).eq('id', id);

        if (error) console.error("Error updating limit:", error);
        fetchData();
    };

    const removeLimit = async (id) => {
        await supabase.from('monthly_limits').delete().eq('id', id);
        fetchData();
    };

    // --- Calculations ---

    const getCurrentBalance = () => {
        const today = new Date();
        today.setHours(23, 59, 59, 999); // Include all of today

        // Only count transactions up to TODAY
        return data.transactions.reduce((acc, curr) => {
            const tDate = new Date(curr.date);
            // Normalize tDate to prevent timezone issues, but usually YYYY-MM-DD input is treated as UTC or local 00:00
            // We just check if it's <= today
            if (tDate <= today) {
                if (curr.type === 'income') return acc + Number(curr.amount);
                else return acc - Number(curr.amount);
            }
            return acc;
        }, data.preferences.initialBalance);
    };

    // Helper for Chart: Daily Balance for Chart
    // supports range (months) and direction ('past' or 'future')
    // options: { excludeCurrentMonthIncome: boolean }
    const getDailyBalanceData = (rangeKey = '1M', direction = 'future', options = {}) => {
        const today = new Date();
        today.setHours(0, 0, 0, 0);

        let startDate, endDate;

        if (direction === 'future') {
            // User requested to always start from Day 1 of the month
            startDate = startOfMonth(today);
            switch (rangeKey) {
                // If user wants extensive future, we still start from 1st of THIS month
                case '3M': endDate = addMonths(today, 3); break;
                case '6M': endDate = addMonths(today, 6); break;
                case '1Y': endDate = addMonths(today, 12); break;
                case '1M': default: endDate = endOfMonth(today); break;
            }
        } else {
            // PAST
            endDate = endOfMonth(today);
            switch (rangeKey) {
                case '3M': startDate = subMonths(today, 2); break;
                case '6M': startDate = subMonths(today, 5); break;
                case '1Y': startDate = subMonths(today, 11); break;
                case '1M': default: startDate = startOfMonth(today); break;
            }
        }

        // Ensure start is start of day
        startDate = startOfDay(startDate);

        // --- Calculate Initial Balance for the Chart Series ---
        let runningBalance = 0;

        // Calculate balance at 'startDate' (which is now Start of Month for future, or historical start for past)
        const initialPref = data.preferences.initialBalance || 0;
        const pastTransactions = data.transactions.filter(t =>
            isBefore(new Date(t.date), startDate)
        );
        const pastIncome = pastTransactions.filter(t => t.type === 'income').reduce((acc, t) => acc + Number(t.amount), 0);
        const pastExpense = pastTransactions.filter(t => t.type === 'expense').reduce((acc, t) => acc + Number(t.amount), 0);
        runningBalance = initialPref + pastIncome - pastExpense;



        const days = eachDayOfInterval({ start: startDate, end: endDate });

        return days.map(day => {
            // New Logic: 
            // 1. Calculate ACTUAL transactions for this day
            const dailyTrans = data.transactions.filter(t => isSameDay(new Date(t.date), day));
            console.log("Daily Trans:", dailyTrans);
            const isCurrentMonth = day.getMonth() === today.getMonth() && day.getFullYear() === today.getFullYear();

            // Calculate Income - Exclude 'Salaire' if in strict mode and end of current month
            const dailyIncome = dailyTrans.filter(t => t.type === 'income').reduce((acc, t) => {
                if (options.excludeCurrentMonthIncome && isCurrentMonth && day.getDate() > 20) {
                    if (t.category === 'Salaire') return acc;
                }
                return acc + Number(t.amount);
            }, 0);

            const dailyExpense = dailyTrans.filter(t => t.type === 'expense').reduce((acc, t) => acc + Number(t.amount), 0);
            // Apply Actual Transactions
            runningBalance += (dailyIncome - dailyExpense);

            // 2. If Future & Day > Today, add Recurring Projections
            // (We skipped "Today" for recurring because we assume "Today" is covered by actuals or user action)
            if (direction === 'future' && isAfter(day, today)) {
                // For every recurring item, check if it triggers on 'day'
                const dayNum = day.getDate();
                const recurringsToday = data.recurring.filter(r => parseInt(r.dayOfMonth) === dayNum);

                recurringsToday.forEach(r => {
                    // avoid double counting if manual transaction exists
                    // Relaxed Match: Same Amount on Same Day (Description optional)
                    const alreadyExists = dailyTrans.some(t =>
                        Math.abs(Number(t.amount) - Number(r.amount)) < 0.01
                    );
                    if (!alreadyExists) {

                        // Strict Rule Conditional: If options.excludeCurrentMonthIncome is true, skip income for this month
                        // Otherwise, include it (for graph).
                        if (options.excludeCurrentMonthIncome && r.type === 'income' && isCurrentMonth) {
                            return;
                        }

                        if (r.type === 'income') runningBalance += Number(r.amount);
                        else runningBalance -= Number(r.amount);
                    }
                });
            }

            return {
                day: format(day, 'd MMM', { locale: fr }),
                balance: runningBalance,
            };
        });
    };

    const getMergedUpcoming = () => {
        const today = new Date();

        today.setHours(23, 59, 59, 999);
        //const endOfNextMonth = addDays(today, 45); // Limit lookahead

        let list = [];

        // 1. Existing Future Transactions
        data.transactions.forEach(t => {
            const tDate = new Date(t.date);
            if (tDate > today) {
                list.push({ ...t, isRecurring: false, origin: 'transaction' });
            }
        });

        // 2. Future Recurring Expenses (Projected)
        // Only project simple next occurrence for now? or multiple? 
        // User asked for "next 10". Let's project occurrences for next 2 months.

        data.recurring.forEach(rec => {
            const dueDay = parseInt(rec.dayOfMonth);
            // Generate date for current month
            let pDate = new Date(today.getFullYear(), today.getMonth(), dueDay);

            // If passed, move to next month
            if (pDate <= today) {
                pDate = new Date(today.getFullYear(), today.getMonth() + 1, dueDay);
            }

            list.push({
                id: `rec-${rec.id}-${format(pDate, 'yyyyMMdd')}`,
                description: rec.description,
                amount: rec.amount,
                type: rec.type,
                category: rec.category || 'Autres',
                date: format(pDate, 'yyyy-MM-dd'),
                isRecurring: true,
                origin: 'recurring'
            });

            // Add next month too just in case
            const nextMonthDate = new Date(today.getFullYear(), today.getMonth() + 2, dueDay);
            list.push({
                id: `rec-${rec.id}-${format(nextMonthDate, 'yyyyMMdd')}`,
                description: rec.description,
                amount: rec.amount,
                type: rec.type,
                category: rec.category || 'Autres',
                date: format(nextMonthDate, 'yyyy-MM-dd'),
                isRecurring: true,
                origin: 'recurring'
            });
        });

        // Sort and Slice
        return list
            .sort((a, b) => new Date(a.date) - new Date(b.date))
            .slice(0, 5);
    }

    const getProjectedBalanceAPI = () => {
        // Reuse the Chart logic to ensure consistency
        // '1M' range covers until end of month
        // Use strictly conservative mode: exclude current month income projection
        const chartData = getDailyBalanceData('1M', 'future', { excludeCurrentMonthIncome: true });
        if (chartData.length > 0) {
            return chartData[chartData.length - 1].balance;
        }
        return getCurrentBalance();
    }

    return (
        <DataContext.Provider value={{
            data,
            addTransaction,
            updateTransaction,
            removeTransaction,
            addRecurring,
            updateRecurring,
            removeRecurring,
            updatePreferences,
            addCategory,
            removeCategory,
            addLimit,
            removeLimit,
            updateLimit,
            getCurrentBalance,
            getProjectedBalanceAPI,
            getDailyBalanceData,
            getMergedUpcoming
        }}>
            {children}
        </DataContext.Provider>
    );
};

export const useData = () => useContext(DataContext);
